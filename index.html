<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>Maven - Capstone Tech Group by tiranno</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>maven --tutorial</h1>
        <h2>N. &quot;an expert or connoisseur&quot;</h2>

        <!-- <section id="downloads">
          <a href="https://github.com/tiranno/maven_techgroup/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/tiranno/maven_techgroup/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/tiranno/maven_techgroup" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section> -->
      </div>
    </header>

    <div class="container">
      <section id="table_contents">
       <h1> Table of Contents </h1>
        <ul>
          <li>
            <a href= "#main_content">Overview and Intro</a></li>
            <ul>
              <li><a href ="#main-definition">What is Maven?</a></li>
              <li><a href ="#main-vs-ant">Maven vs Ant</a></li>
              <li><a href ="#main-overview">What's in this tutorial?</a></li>
            </ul>
          <li>
            <a href= "#eclipse_tut">Tutorial: In Eclipse</a>
           <ul>
           <li><a href="#eclipse-install">Download and Install</a></li>
           <li><a href="#eclipse-create">Create your app</a></li>
           <li><a href="#eclipse-compile">Compile your app</a></li>
           <li><a href="#eclipse-run">Run and Test your app</a></li>
           </ul>
          </li>
          <li>
           <a href= "#id-terminal">Tutorial: In Terminal</a>
           <ul>
           <li><a href="#terminal-download">Download and Install</a></li>
           <li><a href="#terminal-create">Create your app</a></li>
           <li><a href="#terminal-compile-test">Compile and Test your app</a></li>
           <li><a href="#terminal-package">Make a [JAR] Package</a></li>
           </ul>
          </li>
          <li><a href= "#id-log4j">Debugging with Log4j Plugin</a></li>
          <li><a href= "#id-pom">In Depth: the POM file</a></li>
        </ul>
      </section>

      <section id="main_content">
        <section class="">
          <h2>Overview and Intro</h2>
          <article id="main-definition">
            <h3>What is Maven?</h3>
            <p>The word <i>maven</i> comes from Hebrew, where it means accumulator of knowledge. As a technology, Maven is a program to aid in software development. More specifically, Maven is what is called a build automation tool. Maven was created by and is currently maintained by the Apache Software Foundation.</p>
            <h3>What is a build automation tool?</h3>
            <p>Often when software developers are making a project, they have a lot of source code and binary files, as well as included libraries to manage. All these files need to be compiled in a particular order and manner to yield the desired executable or executables. It is an arduous task to manually complete all the build steps for a project every time a change is made. This is the problem build automation tools try to solve. When working on a project the developer just needs to write the build rules down, and then just execute one command. The build automation tool will go through and execute the pre-defined build steps, saving the developer immense time.</p>
            <h4>Example build automation tool - Make</h4>
            <p>A build automation tool developers might be familiar with is the Unix <i>make</i> utility. Make is a relatively simplistic build tool. Imagine a project with all the necessary files in one directory or folder. The developer creates a <i>makefile</i> in the same directory. This file contains &quot;targets&quot;, &quot;dependencies&quot;, &quot;directives&quot;, and some other information. The developer can edit this file, and enter make [TARGET] at the command line. The make utility then finds the TARGET in the makefile and executes all the directives associated with that target.</p>
            <h4>Example build automation tool - Ant</h4>
            <p>Ant, which stands for <i>Another Neat Tool</i>, is another build automation tool developed by Apache in early 2000. The main goal of Ant was to mirror the make utility but for Java projects. The two technologies are similar in function but have slightly different details. For make, the build process is defined in a special file type called a &quot;makefile&quot;, whereas with Ant, the build directives are contained in an XML file format.</p>
            <p>Because Ant uses more generic file formats and was primarily created for Java, it is much more portable than make. In other words, a makefile is specific to an operating system, where Ant can operate accross operating systems using the same files. This portability feature was a primary goal of the project.</p>
          </article>
          <article id="main-vs-ant">
            <h3>Maven vs Ant</h3>
            <p>Apache Maven extends Apache Ant by implementing the paradigm &quot;convention over configuration&quot;. What this means is that Maven assumes that most users want to do the same thing. They probably want to build their projects with the dependencies included, and also generate some tests and information about the project. Therefore, users only need to write down exceptions to the standard build process.</p>
            <p>The default Maven build process is as follows:</p>
            <ol>
              <li>validate</li>
              <li>generate-sources</li>
              <li>process-sources</li>
              <li>generate-resources</li>
              <li>process-resources</li>
              <li>compile</li>
              <li>process-test-sources</li>
              <li>process-test-resources</li>
              <li>test-compile</li>
              <li>test</li>
              <li>package</li>
              <li>install</li>
              <li>deploy</li>
            </ol>
            <p>Since Maven makes some assumptions on what the user wants, the user is given a lot of power. For example, often times developers will use standard libraries created by other developers in their projects. Maven knows that the user will need the code for the libraries to include in the project, so when the user builds a project Maven automatically goes out to the internet to grab the desired binary files.</p>
            <p>There are some consequences of Maven favoring convention over configuration. A developer doesn't need to include as many specific instructions in the build file compared with Ant or make. This does, however, have it's drawbacks. A user needs to understand how Maven behaves before they can understand what Maven will do with a project. A Maven project file contains information that is very specific to Maven. Whereas, with Ant and Make, a developer could probably understand what the script does just by looking at the file.</p>
          </article>
          <article id="main-overview">
            <h3>What's in this tutorial</h3>
            <p>This tutorial will introduce the reader to building projects with Maven. Many developers use Maven as an extension for an IDE, such as Eclipse. Thus, a section of this tutorial is dedicated to using Maven in Eclipse. However, it is not required to use Maven in an IDE, so there is a section on using Maven in the terminal. As an extra, this tutorial also includes a brief section about a handy debugging plugin called log4j. Finally, the tutorial finishes with a section providing more detail on the POM file, which is the name of the file that contains the high level information for a Maven build.</p>
          </article>
          <hr/>
        </section>

        <section id= "eclipse_tut">
          <h2>Tutorial: In Eclipse</h2>


			<h4>NOTE:</h4>
			<p>This section of the tutorial was done on the Eclipse IDE integration. To use Maven on another IDE, please refer to <a href = "https://maven.apache.org/ide.html">Apache Maven IDE Integration</a> page for instructions.</p>
			<p> If you are using Maven directly on the terminal, see: <a href="#id-terminal"><b>Tutorial: In the Terminal</b></a> section.

      <article id = "eclipse-install">
            <h3>$ Download and Install</h3>
			<p>In order to use Maven on Eclipse, you will need the following:</p>
			<ul>
              <li>
                <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                  Java (JDK version 1.7 or greater)
                </a>
              </li>
              <li>
				<a href="https://www.eclipse.org/downloads/">
                Eclipse (Luna or newer)
				</a>
              </li>
            </ul>

			<p>Once you have successfully set up the Java environment and Eclipse IDE, you can go ahead right click on the Help menu, and click on <code>Eclipse Marketplace</code>.</p>
			<img src="./images/help_eclipse_marketplace.png" alt="Maven download" width="650" height="300">
			<p>Search for <code>Maven Integration for Eclipse (Luna and newer)</code> plug-in. Click on the <code>Install</code> button to install Maven Intergration. Follow the instructions and restart Eclipse for new configuration.</p>

          </article>

          <article id= "eclipse-create">
            <h3>$ Create your app</h3>
			<p><h4>Create new Maven project</h4></p>
			<p>Like other Java projects, you can either import an existing Maven project or create a new project. In this section, we are building a new Hello World project in Maven.</p>
			<p>First, click on the File menu and select <code>New->Project</code>. Select <code>Maven Project</code> under Maven folder and click <code>Next</code>.</p>
			<img src="./images/new_maven.png" alt="New Maven Project" width = "400" height="350"/>

			<p>Select <b>Create a simple project</b> if you want to skip archetype selection. Otherwise, an archetype menu will pop up, in which you can choose which archetype you are using for the project. Like Java projects, you can either use the default workplace or specify the path for this project. Click on <code>Next</code> to set up names for the project.</p>
			<img src="./images/new_maven_2.png" alt="New Maven Project Setting" width = "400" height="350"/>

			<p>A Maven project has two artifacts: <code>Group Id</code>and <code>Artifact Id</code>. Group Id is the name of your company/group that identifies your project uniquely across all projects, while Artifact Id is the name of the jar without the version.</p>
			<p>Maven provides users a detailed <a href="https://maven.apache.org/guides/mini/guide-naming-conventions.html">guide for naming conventions</a>, but in this simple project we will just name <code>Group Id</code> as com.capstone.app and <code>Artifact Id</code> as maven-tut. Click <code>Finish</code> to generate a new Maven project.</p>
			<img src="./images/project_id.png" alt="New Maven Project ID" width = "400" height="350"/>

		  <p><h4>Create java class</h4></p>
		  <p>Navigate to <b>maven-tut</b> and right click on <code>src/main/java</code> under the project folder. Select <code>New</code> to create a new Java class. Name the class and click <code>Finish</code>.</p>
		<img src="./images/new_maven_naming.png" alt="New Maven Project ID" width = "400" height="350"/>

		<p><h4>Add code</h4></p>
		<p>Navigate to the Java file we just built and type the code as below: </p>
		<img src="./images/code2.png" alt="Code" width = "400" height="250"/>
		<p>If you are using third-party libraries (like the sample code above), you have to add the dependency in the POM file before compiling and building.</p>

          </article>

          <article id="eclipse-compile">
            <h3>$ Compile your app</h3>
            <p>Compilation is one of the many different phases of the Maven default build process.
            Other phases include validation, testing, packaging, verification, installation,
            and deployment. You can execute all of these phases at one time with Maven!
            </p>
            <p>
            Before you execute the default build process which will build your package, you should
            verify that you are comfortable with your current packaging method in the POM file.
            </p>
    <pre>&lt;packaging&gt;jar&lt;/packaging&gt;</pre>
            <p>
              Appropriate values for packaging include jar, war, ear, and pom. The default
              is jar.
            </p>

          </article>

          <article id="eclipse-run">
            <h3>$ Run and test your app</h3>
            <p>
              Now that the packaging method is taken care of, the next step is to right
              click on the project folder and click on <code>Run As</code>. From there, select <code>Maven build</code>.
            </p>
            <img src="./images/runAs.png" alt="Maven build" width="650" height="250"/>
             <p>
               You will be directed to an Edit Configuration window. In the goals field,
               write <code>package</code> and then click on Run (You can specify additional goals
               in your POM file).
             </p>
             <img src="./images/editConfig.png" alt="Edit Configuration window" width = "450" height="200"/>
             <p>
               Once the build completes, you will find your package file in the target folder of your
               project directory.
             </p>

            <p>
              There are multiple Maven commands within the <code>Run As</code> menu selection shown earlier.
            </p>
            <p>
              For example, there is an option called <code>Maven clean</code> that will remove all of the files created
              during the previous build. This is a good action to take before rebuilding your project.
            </p>
            <p>
              Lastly, there is an option called <code>Maven test</code> that will execute your unit tests. Store
              all of your unit tests in the <code>src/test/java</code> folder because that is where Maven will
              search for them.
            </p>
            <p>
              NOTE: Make sure all of your test files end with Test.java. For example, HelloWorldTest.java.
            </p>
            <p>
              If you would like to run through an example of a unit test, sample code is provided
              below in the
              <a href="#terminal-test">terminal section.</a>
            </p>

          </article>
        </section>
        <hr/>
        <section id="id-terminal">
          <h2>Tutorial: In the Terminal</h2>

          <article id="terminal-download">
            <h3>$ Download and Install</h3>
             <h4>NOTE:</h4>
              <p>
                This section of the tutorial was done on a Linux terminal.
                Windows users can follow along with Command Line by replacing certain
                characters with the proper Windows syntax (i.e. '/' with '\')
              </p>
              <p>
                In order to use Maven you will need the following:
              </p>
              <ul>
                <li>
                  <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">
                    Java (JDK version 1.7 or greater)
                  </a>
                </li>
                <li>
                  10MB of free disk space for installation - plus space for project builds
                </li>
              </ul>
              <p>
                On Ubuntu-based distros you can use the <code>apt-get</code> command to
                install Maven.

                <pre> sudo apt-get install maven</pre>

                If you wish to use Maven on another OS or to install from source
                consult the <a href="https://maven.apache.org/download.cgi#Installation">
                installation instuctions</a> from the Maven project site.
              </p>
              <br/>
          </article>

          <article id="terminal-create">
            <h3>$ Create Your App</h3>
              <p>
                Initializing a new Maven app from the terminal is very simple.
                Go to the directory where you would like your application to exist.
                <br/>
                Use the command below to create your project, replacing the
                <code>groupId</code> with your company/group name and
                <code>artifactId</code> with the name of your app.
                <pre>mvn -B archetype:generate \
      -DarchetypeGroupId=org.apache.maven.archetypes \
      -DgroupId=com.capstone.app \
      -DartifactId=maven-tut
                </pre>
              </p>
              <p>
                After a short wait, your new Maven project now exists in a new
                directory under the project's name. Let's take a quick look at the
                directory structure.
              </p>
              <img src="./images/trm_dir-struct.png" alt="The terminal's directory structure" />
              <p>
                The two main top-level objects are the POM file (pom.xml) and the
                src directory where your code lives.
              </p>
              <p>
                The <b>POM</b> (Project Object Model) file contains all of the important
                information about your project. Described here can be information on
                what package type to compile to, current project version, project
                dependencies, etc. This is the biggest draw to Maven - the POM file
                provides a single point of change for your applications metadata
                and resources.
              </p>
              <aside>
                For more on the POM, see
                <a href="#id-pom"><b>In Depth: POM file section</b></a>
              </aside>
              <p>
                The <b>source</b> (src) folder contains two folders: "main" and "test".
                These folders will [obviously] hold your main app code and your test
                code, respectively.
                <br>
                <br>
              </p>

            <h4>Add Code</h4>
              <p>
                Navigate to <code>maven-tut/src/main/java/com/capstone/app</code>
                here you will find a java file that contains a simple "hello world"
                function.
                <br>
                <article id="terminal-test">
                Here is where we will add our code. For this example, we will be
                using a java library called Guava which contains many core functions
                used by Google's Java-based apps.

              </p>
              <p>
                Next to the main "Hello World" function I created a simple function
                called "arraysToMultimap" that takes in an array of arrays that each start
                with a string and are followed by a number of values (also strings).
                It returns a
                <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multimap.html">
                  Guava Multimap
                </a>
                which maps multiple values to the same
                key).
                <br>
                <br>
                You can see the finished code below to adapt to your own project.
                <br>
                <br>
                We are going to use this code to show how compiling and testing
                works in Maven - and how easy it is.

                <pre>
  package com.capstone.app;

  import java.util.Collection;
  import com.google.common.collect.Multimap;

  public class App {

    public static Multimap<String,String> arraysToMultimap (String[][] arr){
      Multimap<String,String> multimap = ArrayListMultimap.create();

      for(i = 0; i < arr.length; i++ ){
        for(j = 1; j < arr[i].length; j++ ){
          multimap.put( arr[i][0], arr[i][j] );
        }
      }
      return multimap;
    }
  }
                </pre>
                <br>
              </p>

            <h4>Add a Resource</h4>
              <p>
                Now we have code that uses an external Java library but we still
                need to download it in order for our code to take advantage of it.
                Maven makes it easy. Just add a few lines to the POM describing
                the dependency: group-id, library-name, version number.

                <pre> &lt;dependency&gt;
   &lt;groupId&gt;     com.google.guava   &lt;/groupId&gt;
   &lt;artifactId&gt;  guava   &lt;/artifactId&gt;
   &lt;version&gt;     19.0   &lt;/version&gt;
 &lt;/dependency&gt;</pre>

                When we compile (in the next section), everything will be automatically
                downloaded into our project.

                <br><br>
              </p>
       </article>
            <h4>Add a Test</h4>
              <p>
                Now we'll add a quick test to our code.
                In the Maven generated test file add the <code>testArrayToMultimap</code>
                code below to under the <code>testApp()</code> unit test.
                <br>
                Make sure to import Guava with <code>import com.google.common.collect.Multimap;</code>
                at the top of the test file.

                <pre>
  public void testArrayToMultimap()
  {
    String[] lower = { "lower", "a", "b", "c" };
    String[] upper = { "upper", "W", "X", "Y", "Z" };
    String[][] arrays = { lower, upper };

    Multimap<String,String> multimap = ArrayListMultimap.create();
    multimap.put("lower", "a");
    multimap.put("lower", "b");
    multimap.put("lower", "c");
    multimap.put("upper", "W");
    multimap.put("upper", "X");
    multimap.put("upper", "Y");
    multimap.put("upper", "Z");

    assertEquals( multimap , arrayToMultimap(arrays) );
  }</pre>
              </p>
              <p>
                <br>
              </p>
          </article>

          <article id = "terminal-compile-test">
            <h3>$ Compile / Test Your App</h3>
            <h4>Compiling</h4>
              <p>
                Once you satisfied with your app, go back to the terminal and navigate
                to the directory containing the POM file. In our case, it is
                <code>/maven-tut</code>. Then you can run...

                <pre> mvn compile</pre>

                This is why you decided to use Maven.
                <br>
                The compile process automatically downloads all of the dependencies
                descibed in the POM file (in our case Guava).
                Then it will compile the application classes
                and place them in <code>maven-tut/target/classes</code>
                <br>
              </p>

            <h4>Testing</h4>
              <p>
                Maven can also handle automatic unit testing (because we computer
                scientists always write and execute test code).
                Since we have already written a test for our code, go ahead and
                run the following command in the terminal:

                <pre> mvn test</pre>

                Your app will compile and run the tests placed in the test folder.
                Results from these tests will be displayed at the bottom of the terminal
                output.
                <br><br>
              </p>
          </article>

          <article id="terminal-package">
            <h3>$ Make a [JAR] Package</h3>
            <p>
              Now it's time to make your app distributable!
              To do this, follow in the the fashion of the past commands.

              <pre> mvn package</pre>

              The JAR is placed in the <code>/target</code> directory.
              Remember the resources we placed in the project source earlier?
              Maven adds all of the resources in <code>maven-tut/src/main/resources</code>
              to the generated JAR. It's that easy!
              <br>
            </p>
            <p>
              You can go ahead and install from your JAR with <code>mvn install</code>
            </p>
          </article>
        </section>
        <hr />
        <section id="id-log4j">
          <h2>Debugging with Log4j Plugin</h2>
          <article>

           <p> The following section describes a brief introduction to the Log4j Plugin.
             <br/>
             <a href="#id-pom"> Click here to skip to an overview of the POM File</a>
          </p>
            <p> Imagine that you've been working on a coding assignment for a couple of weeks, and
              the day before its due, you discover a bug! Let's assume you were lazy and didn't write any
              jUnit tests. What's the first thing you do?
            </p>
            <p> One possible course of action is to discover where your program first stopped working by adding a ton of
              print statements.
            </p>
            <p>
              However, writing regular print statements is annoying because you eventually have to comment them all out or
              delete them before you turn in your assignment. What if I told you that you could write print statements that
              could appear or disappear on command?
            </p>
            <p>
              Cue the Log4j Plugin, Apache's logging package for Java!
            </p>
            <p>
              This plugin allows you to write logging statements with varying levels of priority. You can also turn off
              these logging statements when they are not needed. Below are the steps to begin using this Plugin:
            </p>
            <p>
              First off, there needs to be a dependency for log4j inside the POM file. Copy the dependency below
               into your POM file between the <code>&lt;dependencies&gt;</code> tags.
            </p>
          <pre>
&lt;dependency&gt;
   &lt;groupId&gt; log4j &lt;/groupId&gt;
   &lt;artifactId&gt; log4j &lt;/artifactId&gt;
   &lt;version&gt; 1.2.17 &lt;/version&gt;
 &lt;/dependency&gt;</pre>
          <p>
            Next, you will need to create a new log4j properties file:
          </p>
          <p>
            Eclipse Users: right click on the src folder of your Maven project,
             and navigate to <code>New</code> then <code>File</code>. Name your new file <code>log4j.properties</code> exactly as spelled here and
             click Finish.
          </p>
          <p>
            Terminal Users: navigate to <code>src/main/java</code> and add a new file called <code>log4j.properties</code> exactly as spelled here
            and save.
          </p>
          <p>
            In your log4j.properties file, copy and paste the following code.
          </p>
         <pre>
  #Root logger option
  log4j.rootLogger = FATAL, console

  #Create appender for console
  log4j.appender.console=org.apache.log4j.ConsoleAppender
  log4j.appender.console.layout=org.apache.log4j.PatternLayout
         </pre>

          <p>
        The first couple of lines are specifying what level of logs that you want to see and where you would like to see them
        outputted. NOTE: The logger will display all elements at the specified logging level and of higher priority.
          </p>
          <p>
            The lines after that initialize the console as an appender to the logger. It is possible to
            use a file as an appender by replacing console with your file name and ConsoleAppender with FileAppender.
          </p>
    <p>
      Now, create a new class in your maven-tut src folder called Log4jDemo.java (For Terminal users, in <code>src/main/java</code>).
      Replace the default code with the code below.
    </p>
    <pre>
import org.apache.log4j.Logger;

public class Log4jDemo {
    //Initialize logger
    static Logger log = Logger.getLogger(Log4jDemo.class);

    public static void main(String[] args) {
        /*Declare different levels of logging messages in order of highest
        priority to lowest priority*/
        log.fatal("This is a fatal message.");
        log.error("This is an error message.");
        log.warn("This is a warning message.");
        log.info("This is an info message.");
        log.debug("This is a debug message.");
        log.trace("This is a trace message.");
    }
}

    </pre>
    <p>
      If your run this file, you will see that only the fatal message prints. This is because you
      specified FATAL on your log4j.properties file.
    </p>
    <p>Try changing the log level on your properties file and rerunning. You will see that log messages of
      this priority level and higher are printed.
    </p>
    <p>
      If you would like to see all of the messages, use <code>ALL</code> in the properties file.
      Similarly, if you would like to see none of the messages, use <code>OFF</code> in the properties
      file.
    </p>
    <p>
      That covers the basic gist of log4j. Learn more at <a href="http://logging.apache.org/log4j/2.x/">
     http://logging.apache.org/log4j/2.x/. </a>
    </p>
  </article>

        </section>
        <hr />
        <section id="id-pom">
          <h2>In Depth: the POM file</h2>
          <p><i>Source From https://maven.apache.org/pom.html</i></p>
          <article>
            <h3> What is the POM file? </h3>
            <p>
              POM stands for "Project Object Model". It is an XML representation of a Maven project held in a file named pom.xml. 
              <br>
              The POM contains information about the project and various configuration detail used by Maven to build the project(s). 
              <br>
              In fact, in the Maven world, a project need not contain any code at all, merely a pom.xml.
            </p>
          </article>

          <article>
            <h3> The Basics </h3>
            <img src="./images/basicPom.png" alt="The terminal's directory structure" />
            <p>
              <h4> Identification </h4>
              <ol>
                <li> groupId </li>
                <li> artifactId </li>
                <li> version </li>
                <li> packaging (optional) </li>
                <img src="./images/packaging.png" alt="The terminal's directory structure" />
                <p> When no packaging is declared, Maven assumes the artifact is the default: jar. The valid types are Plexus role-hints (read more on Plexus for a explanation of roles and role-hints) of the component role org.apache.maven.lifecycle.mapping.LifecycleMapping. The current core packaging values are: pom, jar, maven-plugin, ejb, war, ear, rar, par. These define the default list of goals which execute to each corresponding build lifecycle stage for a particular package structure.</p>
                <li> classifier (optional) </li>
                <p>The classifier allows to distinguish artifacts that were built from the same POM but differ in their content. It is some optional and arbitrary string that - if present - is appended to the artifact name just after the version number.
                <br>As a motivation for this element, consider for example a project that offers an artifact targeting JRE 1.5 but at the same time also an artifact that still supports JRE 1.4. The first artifact could be equipped with the classifier jdk15 and the second one with jdk14 such that clients can choose which one to use.</p>
              </ol>
            </p>
            <h3> POM Relationship </h3>
            <p>
              <h4> POM Relationship - Dependencies </h4>
              <img src="./images/dependenciesList.png" alt="The terminal's directory structure" />
              <p> 
                The cornerstone of the POM is its dependency list. Maven downloads and links the dependencies for you on compilation and other goals that require them. As an added bonus, Maven brings in the dependencies of those dependencies (transitive dependencies), allowing your list to focus solely on the dependencies your project requires.<br>
                <img src="./images/dependenciesWebsite.png" alt="The terminal's directory structure" />
                <br>
                What if my dependencies are not maven artifact? <br>
                There are three methods for dealing with this scenario.
                <ol>
                  <li>
                    Install the dependency locally using the install plugin. The method is the simplest recommended method. For example:
                    <pre>mvn install:install-file -Dfile=non-maven-proj.jar -DgroupId=some.group -DartifactId=non-maven-proj -Dversion=1 -Dpackaging=jar</pre>
                  </li>
                  <li>
                    Create your own repository and deploy it there. This is a favorite method for companies with an intranet and need to be able to keep everyone in synch. There is a Maven goal called deploy:deploy-file which is similar to the install:install-file goal (read the plugin's goal page for more information).
                  </li>
                  <li>
                    Set the dependency scope to system and define a systemPath. (Not Recommended)
                  </li>
                </ol>
              </p>
            </p>
            <p>
              <h4> POM Relationship - Inheritance </h4>
              <img src="./images/inheritance.png" alt="The terminal's directory structure" />
              <p> 
                One powerful addition that Maven brings to build management is the concept of project inheritance. Although in build systems such as Ant, inheritance can certainly be simulated, Maven has gone the extra step in making project inheritance explicit to the project object model.<br>
                <br>
                The elements in the parent POM that are inherited by its children are:<br>
                <ul>
                  <li>dependencies</li>
                  <li>developers and contributors</li>
                  <li>plugin lists</li>
                  <li>reports lists</li>
                  <li>plugin executions with matching ids</li>
                  <li>plugin configuration</li>
                </ul>
                <br>
                You can take a look at how the Super POM affects your Project Object Model by creating a minimal pom.xml and executing on the command line:<br>
                <pre> mvn help:effective-pom </pre>
                <br>
                Just as Java objects ultimately inherit from java.lang.Object, all Project Object Models inherit from a base Super POM.<br>
              </p>
            </p>
            <p>
              <h4> POM Relationship - Aggregation (Multi-Module) </h4>
              <img src="./images/aggregation.png" alt="The terminal's directory structure" />
              <p> 
                A project with modules is known as a multimodule, or aggregator project. Modules are projects that this POM lists, and are executed as a group. An pom packaged project may aggregate the build of a set of projects by listing them as modules, which are relative directories to those projects.<br>
                <br>
              </p>
            </p>
            <h3>Build Settings</h3>
            <p>Beyond the basics of the POM given above, there are two more elements that must be understood before claiming basic competency of the POM. They are the build element, that handles things like declaring your project's directory structure and managing plugins; and the reporting element, that largely mirrors the build element for reporting purposes.</p>
            <img src="./images/BaseElement.png" alt="The terminal's directory structure" />
            <h4>The base set of elements</h4>
            <ul>
              <li>defaultGoal:</li>
              <p>the default goal or phase to execute if none is given. If a goal is given, it should be defined as it is in the command line (such as jar:jar). The same goes for if a phase is defined (such as install).</p>
              <li>directory</li>
              <p>This is the directory where the build will dump its files or, in Maven parlance, the build's target. It aptly defaults to ${basedir}/target.</p>
              <li>finalName</li>
              <p>This is the name of the bundled project when it is finally built (sans the file extension, for example: my-project-1.0.jar). It defaults to ${artifactId}-${version}. The term "finalName" is kind of a misnomer, however, as plugins that build the bundled project have every right to ignore/modify this name (but they usually do not). For example, if the maven-jar-plugin is configured to give a jar a classifier of test, then the actual jar defined above will be built as my-project-1.0-test.jar.</p>
              <li>fliter</li>
              <p>Defines *.properties files that contain a list of properties that apply to resources which accept their settings (covered below). In other words, the "name=value" pairs defined within the filter files replace ${name} strings within resources on build. The example above defines the filter1.properties file under the filter/ directory. Maven's default filter directory is ${basedir}/src/main/filters/.</p>
            </ul>
            <h4>Resources</h4>
            <p>Another feature of build elements is specifying where resources exist within your project. Resources are not (usually) code. They are not compiled, but are items meant to be bundled within your project or used for various other reasons, such as code generation.

            For example, a Plexus project requires a configuration.xml file (which specifies component configurations to the container) to live within the META-INF/plexus directory. Although we could just as easily place this file within src/main/resource/META-INF/plexus, we want instead to give Plexus its own directory of src/main/plexus.</p>
            <h4>Plugins</h4>
            <img src="./images/plugins.png" alt="The terminal's directory structure" />
            <p>Beyond the standard coordinate of groupId:artifactId:version, there are elements which configure the plugin or this builds interaction with it.</p>
            <ul>
              <li>extensions: true or false, whether or not to load extensions of this plugin. It is by default false. Extensions are covered later in this document.</li>
              <li>inherited: true or false, whether or not this plugin configuration should apply to POMs which inherit from this one. Default value is true.</li>
              <li>configuration: This is specific to the individual plugin. Without going too in depth into the mechanics of how plugins work, suffice it to say that whatever properties that the plugin Mojo may expect (these are getters and setters in the Java Mojo bean) can be specified here. In the above example, we are setting the classifier property to test in the maven-jar-plugin's Mojo. It may be good to note that all configuration elements, wherever they are within the POM, are intended to pass values to another underlying system, such as a plugin. In other words: values within a configuration element are never explicitly required by the POM schema, but a plugin goal has every right to require configuration values.</li>
            </ul>
            <h4>Directories</h4>
            <img src="./images/directories.png" alt="The terminal's directory structure" />
            <p>The set of directory elements live in the parent build element, which set various directory structures for the POM as a whole. Since they do not exist in profile builds, these cannot be altered by profiles.</p>
            <h4>Extensions</h4>
            <img src="./images/extensions.png" alt="The terminal's directory structure" />
            <p>Extensions are a list of artifacts that are to be used in this build. They will be included in the running build's classpath. They can enable extensions to the build process (such as add an ftp provider for the Wagon transport mechanism), as well as make plugins active which make changes to the build lifecycle. In short, extensions are artifacts that activated during build. The extensions do not have to actually do anything nor contain a Mojo. For this reason, extensions are excellent for specifying one out of multiple implementations of a common plugin interface.</p>
          </article>

          
        </section>

      </section>
    </div>

  </body>
</html>
